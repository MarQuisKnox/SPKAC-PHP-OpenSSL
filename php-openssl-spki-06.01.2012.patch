--- php-src/ext/openssl/openssl.c	2012-06-01 02:30:12.000000000 -0600
+++ php-src/ext/openssl/openssl.c	2012-05-25 23:24:53.755809270 -0600
@@ -375,11 +383,35 @@
     ZEND_ARG_INFO(0, length)
     ZEND_ARG_INFO(1, result_is_strong)
 ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_spki_new, 0, 0, 2)
+    ZEND_ARG_INFO(0, privkey)
+    ZEND_ARG_INFO(0, challenge)
+    ZEND_ARG_INFO(0, algo)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_verify, 0)
+    ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_export, 0)
+    ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_export_challenge, 0)
+    ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
 /* }}} */
 
 /* {{{ openssl_functions[]
  */
 const zend_function_entry openssl_functions[] = {
+/* spki functions */
+	PHP_FE(openssl_spki_new, arginfo_openssl_spki_new)
+	PHP_FE(openssl_spki_verify, arginfo_openssl_spki_verify)
+	PHP_FE(openssl_spki_export, arginfo_openssl_spki_export)
+	PHP_FE(openssl_spki_export_challenge, arginfo_openssl_spki_export_challenge)
+
 /* public/private key functions */
 	PHP_FE(openssl_pkey_free,			arginfo_openssl_pkey_free)
 	PHP_FE(openssl_pkey_new,			arginfo_openssl_pkey_new)
@@ -770,6 +802,7 @@
 
 static const EVP_CIPHER * php_openssl_get_evp_cipher_from_algo(long algo);
 
+int openssl_spki_cleanup(const char *src, char *dest);
 
 static int php_openssl_parse_config(struct php_x509_request * req, zval * optional_args TSRMLS_DC) /* {{{ */
 {
@@ -1290,6 +1348,296 @@
 }
 /* }}} */
 
+/* {{{ proto string openssl_spki_new(mixed zpkey, string challenge [, mixed method])
+   Creates new private key (or uses existing) and creates a new spki cert
+   outputting results to var */
+PHP_FUNCTION(openssl_spki_new)
+{
+	int challenge_len;
+	char * challenge, * spkstr, * s;
+	long keyresource = -1;
+	const char *spkac = "SPKAC=";
+	long algo = OPENSSL_ALGO_MD5;
+	
+	zval *method = NULL;
+	zval * zpkey = NULL;
+	EVP_PKEY * pkey = NULL;
+	NETSCAPE_SPKI *spki=NULL;
+	const EVP_MD *mdtype;
+	
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs|z", &zpkey, &challenge, &challenge_len, &method) == FAILURE) {
+		return;
+	}
+	
+	pkey = php_openssl_evp_from_zval(&zpkey, 0, challenge, 1, &keyresource TSRMLS_CC);
+	
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied private key");
+		goto cleanup;
+	}
+	
+	if (method != NULL) {
+		if (Z_TYPE_P(method) == IS_LONG) {
+			algo = Z_LVAL_P(method);
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Algorithm must be of supported type");
+			goto cleanup;
+		}
+	}
+	mdtype = php_openssl_get_evp_md_from_algo(algo);
+	
+	if (!mdtype) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown signature algorithm");
+		goto cleanup;
+	}
+	
+	if ((spki = NETSCAPE_SPKI_new()) == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to create new SPKAC");
+		goto cleanup;
+	}
+	
+	if (challenge) {
+		ASN1_STRING_set(spki->spkac->challenge, challenge, (int)strlen(challenge));
+	}
+	
+	if (!NETSCAPE_SPKI_set_pubkey(spki, pkey)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to embed public key");
+		goto cleanup;
+	}
+	
+	if (!NETSCAPE_SPKI_sign(spki, pkey, mdtype)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to sign with specified algorithm");
+		goto cleanup;
+	}
+	
+	spkstr = NETSCAPE_SPKI_b64_encode(spki);
+	if (!spkstr){
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable encode SPKAC");
+		goto cleanup;
+	}
+	
+	s = emalloc(strlen(spkac) + strlen(spkstr) + 1);
+	sprintf(s, "%s%s", spkac, spkstr);
+
+	if (strlen(s)<=0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate memory for SPKAC");
+		goto cleanup;
+	}
+	OPENSSL_free(spkstr);
+	RETURN_STRINGL(s, strlen(s), 0);
+
+cleanup:
+	if (keyresource == -1 && spki) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (keyresource == -1 && pkey) {
+		EVP_PKEY_free(pkey);
+	}
+	if (keyresource == -1 && s) {
+		free(s);
+	}
+	RETURN_NULL();
+}
+/* }}} */
+
+/* {{{ proto bool openssl_spki_verify(string spki)
+   Verifies spki returns boolean */
+PHP_FUNCTION(openssl_spki_verify)
+{
+	int spkstr_len, i=0;
+	char * spkstr, * spkstr_cleaned;
+	
+	EVP_PKEY *pkey = NULL;
+	NETSCAPE_SPKI *spki = NULL;
+	
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+	
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+	
+	if (strlen(spkstr_cleaned)<=0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate memory for SPKAC");
+		goto cleanup;
+	}
+	
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to decode supplied SPKAC");
+		goto cleanup;
+	}
+	
+	pkey = X509_PUBKEY_get(spki->spkac->pubkey);
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to aquire signed public key");
+		goto cleanup;
+	}
+	
+	i = NETSCAPE_SPKI_verify(spki, pkey);
+	if (i > 0) {
+		RETURN_TRUE;
+	} else {
+		RETURN_FALSE;
+	}
+	
+cleanup:
+	if (spki != NULL) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (pkey != NULL) {
+		EVP_PKEY_free(pkey);
+	}
+	if (spkstr != NULL) {
+		OPENSSL_free(spkstr);
+	}
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+}
+/* }}} */
+
+/* {{{ proto string openssl_spki_export(string spki)
+   Exports public key from existing spki to var */
+PHP_FUNCTION(openssl_spki_export)
+{
+	int spkstr_len;
+	char * spkstr, * spkstr_cleaned, * s;
+	
+	EVP_PKEY *pkey = NULL;
+	NETSCAPE_SPKI *spki = NULL;
+	BIO *out = BIO_new(BIO_s_mem());
+	BUF_MEM *bio_buf;
+	
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+	
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+	
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to decode supplied SPKAC");
+		goto cleanup;
+	}
+	
+	pkey = X509_PUBKEY_get(spki->spkac->pubkey);
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to aquire signed public key");
+		goto cleanup;
+	}
+	
+	PEM_write_bio_PUBKEY(out, pkey);
+	BIO_get_mem_ptr(out, &bio_buf);
+	
+	if ((!bio_buf->data)&&(bio_buf->length<=0)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate memory for public key");
+		goto cleanup;
+	}
+	
+	s = emalloc(bio_buf->length);
+	BIO_read(out, s, bio_buf->length);
+
+	if (strlen(s) > 0) {
+		RETURN_STRINGL(s, strlen(s), 1);
+	} else {
+		goto cleanup;
+	}
+	
+cleanup:
+	if (spki != NULL) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (out != NULL) {
+		BIO_free_all(out);
+	}
+	if (pkey != NULL) {
+		EVP_PKEY_free(pkey);
+	}
+	if (spkstr != NULL) {
+		OPENSSL_free(spkstr);
+	}
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+	RETURN_NULL();
+}
+/* }}} */
+
+/* {{{ proto string openssl_spki_export_challenge(string spki)
+   Exports spkac challenge from existing spki to var */
+PHP_FUNCTION(openssl_spki_export_challenge)
+{
+	int spkstr_len;
+	char * spkstr, * spkstr_cleaned;
+	
+	NETSCAPE_SPKI *spki = NULL;
+	
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+	
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+	
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to allocate memory for public key");
+		goto cleanup;
+	}
+
+	if (strlen(ASN1_STRING_data(spki->spkac->challenge)) > 0) {
+		RETURN_STRING(ASN1_STRING_data(spki->spkac->challenge), 1);
+	}
+	goto cleanup;
+
+cleanup:
+	if (spkstr != NULL) {
+		efree(spkstr);
+	}
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+	RETURN_NULL();
+}
+/* }}} */
+
+/* {{{ proto int openssl_spki_cleanup(const char *src, char *results)
+  This will help remove new line chars in the SPKAC sent from the
+  browser */
+int openssl_spki_cleanup(const char *src, char *dest)
+{
+    int removed=0;
+
+    while (*src) {
+        if (*src!='\n'&&*src!='\r') {
+            *dest++=*src;
+        } else {
+            ++removed;
+        }
+        ++src;
+    }
+    *dest=0;
+    return removed;
+}
+/* }}} */
+
 /* {{{ proto bool openssl_x509_export(mixed x509, string &out [, bool notext = true])
    Exports a CERT to file or a var */
 PHP_FUNCTION(openssl_x509_export)
--- php-src/ext/openssl/php_openssl.h	2012-06-01 02:30:12.000000000 -0600
+++ php-src/ext/openssl/php_openssl.h	2012-04-06 04:40:17.691593429 -0600
@@ -77,6 +77,11 @@
 PHP_FUNCTION(openssl_csr_sign);
 PHP_FUNCTION(openssl_csr_get_subject);
 PHP_FUNCTION(openssl_csr_get_public_key);
+
+PHP_FUNCTION(openssl_spki_new);
+PHP_FUNCTION(openssl_spki_verify);
+PHP_FUNCTION(openssl_spki_export);
+PHP_FUNCTION(openssl_spki_export_challenge);
 #else
 
 #define phpext_openssl_ptr NULL
--- php-src/ext/openssl/tests/openssl_spki_export_challenge.phpt	1969-12-31 17:00:00.000000000 -0700
+++ php-src/ext/openssl/tests/openssl_spki_export_challenge.phpt	2012-05-25 23:39:31.343821621 -0600
@@ -0,0 +1,54 @@
+--TEST--
+Testing openssl_spki_export_challenge()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+echo "Creating private key...";
+$pkey = openssl_pkey_new(array('digest_alg' => 'sha512',
+                               'private_key_type' => OPENSSL_KEYTYPE_RSA,
+                               'private_key_bits' => 2048));
+openssl_pkey_export($pkey, $pass);
+echo "ok!\n\n";
+
+/* testing all signing algorithms */
+$algos = array('MD5'=>OPENSSL_ALGO_MD5,
+               'SHA1'=>OPENSSL_ALGO_SHA1,
+			   'SHA256'=>OPENSSL_ALGO_SHA256,
+			   'SHA512'=>OPENSSL_ALGO_SHA512);
+
+foreach($algos as $key => $value) {
+
+	if (function_exists('openssl_spki_new')){
+		$spki = openssl_spki_new($pkey, _uuid(), $value);
+	}
+
+	echo "Exporting challenge from SPKAC with ".$key."...";
+	if (function_exists('openssl_spki_export_challenge')){
+		$x = openssl_spki_export_challenge(preg_replace('/SPKAC=/', '', $spki));
+	}
+	echo "ok!\n";
+}
+
+openssl_free_key($pkey);
+
+function _uuid()
+{
+ return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff),
+                mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000,
+                mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff),
+                mt_rand(0, 0xffff), mt_rand(0, 0xffff));
+}
+
+?>
+--EXPECT--
+Creating private key...ok!
+
+Exporting challenge from SPKAC with MD5...ok!
+Exporting challenge from SPKAC with SHA1...ok!
+Exporting challenge from SPKAC with SHA256...ok!
+Exporting challenge from SPKAC with SHA512...ok!
--- php-src/ext/openssl/tests/openssl_spki_export.phpt	1969-12-31 17:00:00.000000000 -0700
+++ php-src/ext/openssl/tests/openssl_spki_export.phpt	2012-04-06 04:40:17.726749094 -0600
@@ -0,0 +1,41 @@
+--TEST--
+Testing openssl_spki_export()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+/* private key creation */
+echo "Creating private key...";
+$pkey = openssl_pkey_new();
+echo ($pkey !== false) ?
+ "ok!\n\n" : "error creating private key\n\n";
+
+/* testing all signing algorithms */
+$algos = array('MD5'=>OPENSSL_ALGO_MD5,
+               'SHA1'=>OPENSSL_ALGO_SHA1,
+			   'SHA256'=>OPENSSL_ALGO_SHA256,
+			   'SHA512'=>OPENSSL_ALGO_SHA512);
+
+/* loop to create, export public keys and verify */
+foreach($algos as $key => $value){
+ echo "Exporting public key from SPKAC with ".$key."...";
+ $spki = openssl_spki_new($pkey, "sample_challenge_string", $value);
+ if ((!empty($spki)) && (preg_match('/SPKAC=[a-zA-Z0-9\/\+]/', $spki)))
+  $r = openssl_spki_export(preg_replace('/SPKAC=/', '', $spki)); 
+  if (preg_match("/-----BEGIN PUBLIC KEY-----/", $r))
+   echo "ok!\n";
+}
+
+openssl_free_key($pkey);
+?>
+--EXPECT--
+Creating private key...ok!
+
+Exporting public key from SPKAC with MD5...ok!
+Exporting public key from SPKAC with SHA1...ok!
+Exporting public key from SPKAC with SHA256...ok!
+Exporting public key from SPKAC with SHA512...ok!
--- php-src/ext/openssl/tests/openssl_spki_new.phpt	1969-12-31 17:00:00.000000000 -0700
+++ php-src/ext/openssl/tests/openssl_spki_new.phpt	2012-04-06 04:40:17.727590617 -0600
@@ -0,0 +1,39 @@
+--TEST--
+Testing openssl_spki_new()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+/* private key creation */
+echo "Creating private key...";
+$pkey = openssl_pkey_new();
+echo ($pkey !== false) ?
+ "ok!\n\n" : "error creating private key\n\n";
+
+/* testing all signing algorithms */
+$algos = array('MD5'=>OPENSSL_ALGO_MD5,
+               'SHA1'=>OPENSSL_ALGO_SHA1,
+			   'SHA256'=>OPENSSL_ALGO_SHA256,
+			   'SHA512'=>OPENSSL_ALGO_SHA512);
+
+/* loop to create and verify results */
+foreach($algos as $key => $value){
+ echo "Creating new SPKAC with ".$key."...";
+ $spki = openssl_spki_new($pkey, "sample_challenge_string", $value);
+ if ((!empty($spki)) && (preg_match('/SPKAC=[a-zA-Z0-9\/\+]/', $spki)))
+  echo "ok!\n";
+}
+
+openssl_free_key($pkey);
+?>
+--EXPECT--
+Creating private key...ok!
+
+Creating new SPKAC with MD5...ok!
+Creating new SPKAC with SHA1...ok!
+Creating new SPKAC with SHA256...ok!
+Creating new SPKAC with SHA512...ok!
--- php-src/ext/openssl/tests/openssl_spki_verify.phpt	1969-12-31 17:00:00.000000000 -0700
+++ php-src/ext/openssl/tests/openssl_spki_verify.phpt	2012-04-06 04:40:17.728589669 -0600
@@ -0,0 +1,40 @@
+--TEST--
+Testing openssl_spki_verify()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+/* private key creation */
+echo "Creating private key...";
+$pkey = openssl_pkey_new();
+echo ($pkey !== false) ?
+ "ok!\n\n" : "error creating private key\n\n";
+
+/* testing all signing algorithms */
+$algos = array('MD5'=>OPENSSL_ALGO_MD5,
+               'SHA1'=>OPENSSL_ALGO_SHA1,
+			   'SHA256'=>OPENSSL_ALGO_SHA256,
+			   'SHA512'=>OPENSSL_ALGO_SHA512);
+
+/* loop to create and verify results */
+foreach($algos as $key => $value){
+ echo "Performing verification of SPKAC with ".$key."...";
+ $spki = openssl_spki_new($pkey, "sample_challenge_string", $value);
+ if ((!empty($spki)) && (preg_match('/SPKAC=[a-zA-Z0-9\/\+]/', $spki)))
+  if (openssl_spki_verify(preg_replace('/SPKAC=/', '', $spki)))
+   echo "ok!\n";
+}
+
+openssl_free_key($pkey);
+?>
+--EXPECT--
+Creating private key...ok!
+
+Performing verification of SPKAC with MD5...ok!
+Performing verification of SPKAC with SHA1...ok!
+Performing verification of SPKAC with SHA256...ok!
+Performing verification of SPKAC with SHA512...ok!
